
channelBits:    .db 1, 2, 4, 8, 1, 2, 4, 8

outputTrianglePeriod:
    ldx curStream
    cpx #4          ; get offset for pitch vars
    bcc +
    dex
+   lda nesmus.periodL, x
    sta $400A
    lda nesmus.periodH, x
    ora #$80
    sta $400B
    ldx curStream
    rts

outputSweep:
    cpx #4
    bcc +
    dex
    dex
+   lda nesmus.pulseSweep, x
    bmi +
    lda #$0F
+   ldx curChannel
    cmp nesmus.prevPulseSweep, x
    beq outputPulsePeriod
    sta nesmus.prevPulseSweep, x
    sta $4001, y

outputPulsePeriod:
    ldx curStream                   ; get offset for pitch vars
    cpx #4          
    bcc +
    dex
    
+   ldy curChannel                  ; if hardware sweep disabled, branch for software pitch
    lda nesmus.prevPulseSweep, y
    bpl @checkPeriodH
    ldy curStream                   ; else check if new note started
    lda newNoteFlags
    and streamBits.w, y
    beq @done                       ; if not, do nothing
    lda nesmus.periodH, x           ; else load high period and branch to output
    jmp @writePeriodH
    
@checkPeriodH
    ldy curChannel                  
    lda nesmus.periodH, x           ; get high period
    and #7
    cmp nesmus.prevPeriodH, y       ; skip writing if not changed
    beq @writePeriodL    
@writePeriodH
    ldy curChannel 
    sta nesmus.prevPeriodH, y
    ldy outputOffs
    ora #$80
    sta $4003, y
@writePeriodL
    ldy outputOffs
    lda nesmus.periodL, x           ; else, write low period if changed
    sta $4002, y
@done    
    ldx curStream
    rts
    
outputNoisePeriod:
    ldx curStream
    cpx #7
    bne @drum
    lda nesmus.curNote+7
    and #$0F
@writeNoise
    sta $400E
    lda #$80
    sta $400F
    bne outputPulsePeriod@done
@drum
    lda nesmus.envValue+2
    lsr
    lsr
    lsr
    lsr
    eor #$0F
    jmp @writeNoise
    
muteChannel:
    cpy #8
    beq muteTriangle
    lda #$30
    sta $4000, y
    rts
muteTriangle:
    lda #0
    sta $4008
    lda #$87
    sta $400B
--  rts

outputStream:
    ldy outputOffs
    lda nesmus.streamFlags, x
    bmi +
-   cpx #4
    bcc muteChannel
    rts
; check for note off 
    
; check if there is already output on this channel. skip this one if yes.
+   lda channelBits.w, x
    and outputMask
    bne --
    lda nesmus.streamFlags, x
    and #3
    beq -
    
; if stream is enabled, go ahead. otherwise, for music streams (0-3) mute the channel, for sfx streams just skip
; set flag for this channel in output mask
+   lda channelBits.w, x
    ora outputMask
    sta outputMask
; branch for triangle channel.
    cpy #8
    beq outputTriangle
    bcs outputNoise
; output pulse channels    
    jsr outputVolume
    jmp outputSweep
    
outputTriangle:
; mute channel if note off or stream volume == 0 or note volume == 0
; play sound otherwise
    lda nesmus.streamVolume, x
    and nesmus.noteVolume, x
    beq muteTriangle
    lda nesmus.streamFlags, x
    and #3
    beq muteTriangle
    lda #$FF
    sta $4008
    jmp outputTrianglePeriod
    
outputNoise:
    jsr outputVolume
    jmp outputNoisePeriod
    
-   jmp muteChannel
outputVolume:
    cpx #4
    bcs @sfx
@envelope
    cpx #3
    bne +
    dex
+   lda nesmus.envValue, x
    jmp applyGain
@sfx
    lda #$0F
    cpx #6
    bcs +
    ora nesmus.sfxDuty-4, x
    ldx curStream
applyGain:
    sta tmpvar
    and #$0F
    beq -
    sta tmpvar+1
    lda nesmus.streamVolume, x
    beq -
    lda nesmus.noteVolume, x
    beq -
    clc
    adc nesmus.streamVolume, x
    clc
    adc tmpvar+1
    sec
    sbc #30
    cmp #$0F
    bmi +
    lda #$0F
+   cmp #1
    bpl +
    lda #1
+   sta tmpvar+1
    lda tmpvar
    and #$C0
    ora tmpvar+1
    ora #$30
    sta $4000, y
    rts
    
; volume = envValue - (15 - streamVol) - (15 - noteVol)
;        = envValue + streamVol + noteVol - 30
    