releaseEnvelope:                            ; get saved envelope var offset
    ldy nesmus.envId, x                     ; use envelope id as index
    lda nesmus.envReleaseOffsTable.w, y     ; use pulse envelope as default
    cpx #2                                  ; override if drum envelope
    bcc +
    lda nesmus.drumReleaseOffsTable.w, y
+   sta nesmus.envOffs, x                   ; save new offset
    dec nesmus.streamFlags, x               ; decrement note state
-   rts
updateEnvelope:
    jsr getEnvelopeX            ; get envelope var offset for this stream
    bcs -                       ; if stream doesn't have envelope, return
    
    ldx curStream               ; if note off or held, return
    lda nesmus.streamFlags, x 
    and #3
    cmp #2
    bcc -
    
    ; handle note release
    ldx envX
    cmp #3
    bne +
    jsr releaseEnvelope
    jmp nextEnvCmd ; continue
    
+   lda nesmus.envId, x ; use envelope id (for drums, this equals the current note) as pointer-table index
    asl
    tay
    cpx #2
    beq updateDrumEnvelope ; branch for noise channel
    lda nesmus.envelopeTable.w, y
    sta dataPtr
    lda nesmus.envelopeTable+1.w, y
    sta dataPtr+1
    ldy nesmus.envOffs, x
nextEnvCmd:
    lda (dataPtr), y    ; get next command byte
    cmp #$FF            ; $FF = hold previous value
    beq env.holdValue
+   iny
    cmp #$FE            ; $FE = jump to offset
    bne +
    lda (dataPtr), y
    tay
    jmp nextEnvCmd
+   cmp #$FD
    beq env.cutNote
    sta tmpvar          ; save command
    and #$CF            ; save envelope value
    sta nesmus.envValue, x
    lda tmpvar          ; d4 set -> read length byte
    and #$10
    bne +
    lda (dataPtr), y
    iny
    sta nesmus.envTimer, x
+   tya
    sta nesmus.envOffs, x   ; save envelope offset
    ldx curStream
    rts
    
env.holdValue:
    ldx curStream
    lda nesmus.streamFlags, x
    and #$FC
    ora #1
    sta nesmus.streamFlags, x
    rts
    
env.cutNote:
    ldx curStream
    jsr cutNote
    rts
    
updateDrumEnvelope:
    lda nesmus.drumTable.w, y   ; get envelope pointer from drum table
    sta dataPtr
    lda nesmus.drumTable+1.w,y
    sta dataPtr+1
    ldy nesmus.drumOffs
nextDrumEnv:
    lda nesmus.drumBytes    ; more bytes in this chunk?
    beq drumChunkHeader     ; if not, read chunk header
readDrumValue:
    dec nesmus.drumBytes    ; decrement byte count
    lda nesmus.drumLength   ; reload length
    sta nesmus.drumTimer    
    lda (dataPtr), y        ; get next envelope value
    iny
    sta nesmus.drumValue
    sty nesmus.drumOffs
    rts
drumChunkHeader:
    lda (dataPtr), y        ; else read chunk header byte
    beq env.holdValue      ; zero -> we're done, hold last value
    sta tmpvar              ; else save
    cmp #$10                ; $00-$0F -> special commands
    bcc +
    lsr                     ; else: byte count in upper nybble
    lsr
    lsr
    lsr
    sta nesmus.drumBytes
    lda tmpvar              ; frame count in lower nybble
    and #$0F
    sta nesmus.drumLength
    bne readDrumValue       ; unconditional branch
+   and #3                  ; only use low 2 bits
    jump_table drumCmds, tmpvar+1

drumCmds:
    .dw env.holdValue    -1
    .dw env.cutNote      -1
    .dw drum.setOffs     -1
    .dw env.holdValue    -1
    
drum.setOffs:
    iny
    lda (dataPtr), y
    tay
    jmp nextDrumEnv    
    
updatePitchbend:
    ldx curStream
    lda nesmus.streamFlags, x  
    sta tmpvar
    and #PFX_ENABLE
    bne +
-   rts
+   jsr getPitchX
    ; decrement pitchbend timer
    dec nesmus.pitchbendTimer, x
    bne -
    lda nesmus.pitchbendSpeed, x
    sta nesmus.pitchbendTimer, x
    ; if vibrato mode, handle things slightly differently
    lda tmpvar
    and #PFX_MASK
    cmp #PFX_PORTA_DOWN
    beq pitchbendDown
    cmp #PFX_PORTA_UP
    beq pitchbendUp
    cmp #PFX_VIBRATO
    beq updateVibrato
    rts
    
pitchbendDown:
    lda nesmus.pitchbendDelta, x
    jmp addPeriod
    
; this creates a 4-phase vibrato cycle
updateVibrato:
    lda tmpvar
    eor #PFX_VIBRATO_TOG
    sta tmpvar
    and #PFX_VIBRATO_TOG
    beq +
    lda tmpvar
    eor #PFX_VIBRATO_DIR
    sta tmpvar
    and #PFX_VIBRATO_DIR
+   bne pitchbendDown
    
pitchbendUp:
    lda nesmus.pitchbendDelta, x
    jmp subtractPeriod
    
subtractPeriod:
    sta tmpvar
    sec
    lda nesmus.periodL, x
    sbc tmpvar
    bcs +
    sta tmpvar
    lda nesmus.periodH, x
    beq +
    sbc #0
    sta nesmus.periodH, x
    lda tmpvar
+   sta nesmus.periodL, x
    rts
    
addPeriod:
    clc
    adc nesmus.periodL, x
    bcc ++
    lda nesmus.periodH, x
    adc #0
    cmp #8
    bcc +
    lda #$07
+   sta nesmus.periodH, x
    lda #$FF 
++  sta nesmus.periodL, x
    rts
    
    